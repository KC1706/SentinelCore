"""
Vulnerability Database MCP Server

Provides unified interface for vulnerability databases including CVE, NVD, 
MITRE, and custom vulnerability feeds with real-time updates and correlation.
"""

import asyncio
import json
import logging
import aiohttp
import sqlite3
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass, asdict
from pathlib import Path
import hashlib
import xml.etree.ElementTree as ET

from mcp import ClientSession, StdioServerParameters
from mcp.server import Server
from mcp.types import (
    CallToolRequest, 
    CallToolResult, 
    ListToolsRequest, 
    Tool, 
    TextContent
)

from .tool_registry import ToolRegistry, ToolCapability, ToolParameter


@dataclass
class Vulnerability:
    """Standardized vulnerability data structure"""
    cve_id: str
    title: str
    description: str
    severity: str
    cvss_v3_score: Optional[float]
    cvss_v2_score: Optional[float]
    published_date: datetime
    modified_date: datetime
    affected_products: List[str]
    references: List[str]
    cwe_ids: List[str]
    exploit_available: bool
    patch_available: bool
    vendor_advisories: List[Dict[str, str]]
    threat_intelligence: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        data = asdict(self)
        data['published_date'] = self.published_date.isoformat()
        data['modified_date'] = self.modified_date.isoformat()
        return data


@dataclass
class VulnerabilitySearchResult:
    """Search result container"""
    query: str
    total_results: int
    vulnerabilities: List[Vulnerability]
    search_time_ms: float
    filters_applied: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'query': self.query,
            'total_results': self.total_results,
            'vulnerabilities': [vuln.to_dict() for vuln in self.vulnerabilities],
            'search_time_ms': self.search_time_ms,
            'filters_applied': self.filters_applied
        }


class VulnerabilityDatabase:
    """Local vulnerability database with caching and indexing"""
    
    def __init__(self, db_path: str = "vulnerability_db.sqlite"):
        self.db_path = db_path
        self.connection: Optional[sqlite3.Connection] = None
        self.logger = logging.getLogger(__name__)
        
    async def initialize(self):
        """Initialize database schema"""
        self.connection = sqlite3.connect(self.db_path)
        self.connection.row_factory = sqlite3.Row
        
        # Create tables
        await self._create_tables()
        await self._create_indexes()
        
        self.logger.info("Vulnerability database initialized")
    
    async def _create_tables(self):
        """Create database tables"""
        cursor = self.connection.cursor()
        
        # Main vulnerabilities table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                cve_id TEXT PRIMARY KEY,
                title TEXT NOT NULL,
                description TEXT,
                severity TEXT,
                cvss_v3_score REAL,
                cvss_v2_score REAL,
                published_date TEXT,
                modified_date TEXT,
                affected_products TEXT,  -- JSON array
                references TEXT,         -- JSON array
                cwe_ids TEXT,           -- JSON array
                exploit_available BOOLEAN DEFAULT FALSE,
                patch_available BOOLEAN DEFAULT FALSE,
                vendor_advisories TEXT, -- JSON array
                threat_intelligence TEXT, -- JSON object
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Product mappings table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS product_mappings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT,
                vendor TEXT,
                product TEXT,
                version TEXT,
                FOREIGN KEY (cve_id) REFERENCES vulnerabilities (cve_id)
            )
        """)
        
        # Exploit mappings table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploit_mappings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT,
                exploit_db_id TEXT,
                metasploit_module TEXT,
                exploit_type TEXT,
                reliability TEXT,
                FOREIGN KEY (cve_id) REFERENCES vulnerabilities (cve_id)
            )
        """)
        
        # Search cache table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS search_cache (
                query_hash TEXT PRIMARY KEY,
                query TEXT,
                results TEXT,  -- JSON
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP
            )
        """)
        
        self.connection.commit()
    
    async def _create_indexes(self):
        """Create database indexes for performance"""
        cursor = self.connection.cursor()
        
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_severity ON vulnerabilities(severity)",
            "CREATE INDEX IF NOT EXISTS idx_published_date ON vulnerabilities(published_date)",
            "CREATE INDEX IF NOT EXISTS idx_cvss_v3 ON vulnerabilities(cvss_v3_score)",
            "CREATE INDEX IF NOT EXISTS idx_product_vendor ON product_mappings(vendor, product)",
            "CREATE INDEX IF NOT EXISTS idx_exploit_available ON vulnerabilities(exploit_available)",
            "CREATE INDEX IF NOT EXISTS idx_search_expires ON search_cache(expires_at)"
        ]
        
        for index_sql in indexes:
            cursor.execute(index_sql)
        
        self.connection.commit()
    
    async def store_vulnerability(self, vulnerability: Vulnerability):
        """Store vulnerability in database"""
        cursor = self.connection.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO vulnerabilities (
                cve_id, title, description, severity, cvss_v3_score, cvss_v2_score,
                published_date, modified_date, affected_products, references, cwe_ids,
                exploit_available, patch_available, vendor_advisories, threat_intelligence,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        """, (
            vulnerability.cve_id,
            vulnerability.title,
            vulnerability.description,
            vulnerability.severity,
            vulnerability.cvss_v3_score,
            vulnerability.cvss_v2_score,
            vulnerability.published_date.isoformat(),
            vulnerability.modified_date.isoformat(),
            json.dumps(vulnerability.affected_products),
            json.dumps(vulnerability.references),
            json.dumps(vulnerability.cwe_ids),
            vulnerability.exploit_available,
            vulnerability.patch_available,
            json.dumps(vulnerability.vendor_advisories),
            json.dumps(vulnerability.threat_intelligence)
        ))
        
        self.connection.commit()
    
    async def search_vulnerabilities(self, query: str, filters: Dict[str, Any] = None, 
                                   limit: int = 100) -> List[Vulnerability]:
        """Search vulnerabilities with filters"""
        cursor = self.connection.cursor()
        
        # Build SQL query
        sql = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        # Text search
        if query:
            sql += " AND (title LIKE ? OR description LIKE ? OR cve_id LIKE ?)"
            search_term = f"%{query}%"
            params.extend([search_term, search_term, search_term])
        
        # Apply filters
        if filters:
            if 'severity' in filters:
                sql += " AND severity = ?"
                params.append(filters['severity'])
            
            if 'min_cvss' in filters:
                sql += " AND cvss_v3_score >= ?"
                params.append(filters['min_cvss'])
            
            if 'max_cvss' in filters:
                sql += " AND cvss_v3_score <= ?"
                params.append(filters['max_cvss'])
            
            if 'exploit_available' in filters:
                sql += " AND exploit_available = ?"
                params.append(filters['exploit_available'])
            
            if 'published_after' in filters:
                sql += " AND published_date >= ?"
                params.append(filters['published_after'])
            
            if 'published_before' in filters:
                sql += " AND published_date <= ?"
                params.append(filters['published_before'])
        
        # Add ordering and limit
        sql += " ORDER BY published_date DESC LIMIT ?"
        params.append(limit)
        
        cursor.execute(sql, params)
        rows = cursor.fetchall()
        
        vulnerabilities = []
        for row in rows:
            vuln = Vulnerability(
                cve_id=row['cve_id'],
                title=row['title'],
                description=row['description'],
                severity=row['severity'],
                cvss_v3_score=row['cvss_v3_score'],
                cvss_v2_score=row['cvss_v2_score'],
                published_date=datetime.fromisoformat(row['published_date']),
                modified_date=datetime.fromisoformat(row['modified_date']),
                affected_products=json.loads(row['affected_products'] or '[]'),
                references=json.loads(row['references'] or '[]'),
                cwe_ids=json.loads(row['cwe_ids'] or '[]'),
                exploit_available=bool(row['exploit_available']),
                patch_available=bool(row['patch_available']),
                vendor_advisories=json.loads(row['vendor_advisories'] or '[]'),
                threat_intelligence=json.loads(row['threat_intelligence'] or '{}')
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def get_vulnerability_by_cve(self, cve_id: str) -> Optional[Vulnerability]:
        """Get specific vulnerability by CVE ID"""
        results = await self.search_vulnerabilities(cve_id, limit=1)
        return results[0] if results else None


class VulnerabilityFeedManager:
    """Manages vulnerability feeds from multiple sources"""
    
    def __init__(self, database: VulnerabilityDatabase):
        self.database = database
        self.logger = logging.getLogger(__name__)
        
        # Feed configurations
        self.feeds = {
            'nvd': {
                'url': 'https://services.nvd.nist.gov/rest/json/cves/2.0',
                'api_key': None,  # Set from environment
                'rate_limit': 5,  # requests per second
                'last_update': None
            },
            'mitre': {
                'url': 'https://cve.mitre.org/data/downloads/allitems.xml',
                'rate_limit': 1,
                'last_update': None
            },
            'exploit_db': {
                'url': 'https://www.exploit-db.com/api/v1/search',
                'rate_limit': 2,
                'last_update': None
            }
        }
    
    async def update_nvd_feed(self, days_back: int = 7) -> int:
        """Update from NVD feed"""
        try:
            updated_count = 0
            
            # Calculate date range
            end_date = datetime.now(timezone.utc)
            start_date = end_date - timedelta(days=days_back)
            
            async with aiohttp.ClientSession() as session:
                # NVD API pagination
                start_index = 0
                results_per_page = 100
                
                while True:
                    params = {
                        'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
                        'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
                        'startIndex': start_index,
                        'resultsPerPage': results_per_page
                    }
                    
                    async with session.get(self.feeds['nvd']['url'], params=params) as response:
                        if response.status == 200:
                            data = await response.json()
                            
                            vulnerabilities = data.get('vulnerabilities', [])
                            if not vulnerabilities:
                                break
                            
                            for vuln_data in vulnerabilities:
                                cve = vuln_data.get('cve', {})
                                vulnerability = await self._parse_nvd_vulnerability(cve)
                                
                                if vulnerability:
                                    await self.database.store_vulnerability(vulnerability)
                                    updated_count += 1
                            
                            start_index += results_per_page
                            
                            # Rate limiting
                            await asyncio.sleep(1.0 / self.feeds['nvd']['rate_limit'])
                        else:
                            self.logger.error(f"NVD API error: {response.status}")
                            break
            
            self.feeds['nvd']['last_update'] = datetime.now(timezone.utc)
            self.logger.info(f"Updated {updated_count} vulnerabilities from NVD")
            
            return updated_count
            
        except Exception as e:
            self.logger.error(f"Failed to update NVD feed: {str(e)}")
            return 0
    
    async def _parse_nvd_vulnerability(self, cve_data: Dict[str, Any]) -> Optional[Vulnerability]:
        """Parse NVD CVE data into Vulnerability object"""
        try:
            cve_id = cve_data.get('id', '')
            if not cve_id:
                return None
            
            # Extract basic information
            descriptions = cve_data.get('descriptions', [])
            description = ''
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # Extract CVSS scores
            metrics = cve_data.get('metrics', {})
            cvss_v3_score = None
            cvss_v2_score = None
            
            if 'cvssMetricV31' in metrics:
                cvss_v3_score = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
            elif 'cvssMetricV30' in metrics:
                cvss_v3_score = metrics['cvssMetricV30'][0]['cvssData']['baseScore']
            
            if 'cvssMetricV2' in metrics:
                cvss_v2_score = metrics['cvssMetricV2'][0]['cvssData']['baseScore']
            
            # Determine severity
            severity = 'unknown'
            if cvss_v3_score:
                if cvss_v3_score >= 9.0:
                    severity = 'critical'
                elif cvss_v3_score >= 7.0:
                    severity = 'high'
                elif cvss_v3_score >= 4.0:
                    severity = 'medium'
                else:
                    severity = 'low'
            
            # Extract dates
            published_date = datetime.fromisoformat(cve_data.get('published', '').replace('Z', '+00:00'))
            modified_date = datetime.fromisoformat(cve_data.get('lastModified', '').replace('Z', '+00:00'))
            
            # Extract affected products
            affected_products = []
            configurations = cve_data.get('configurations', [])
            for config in configurations:
                for node in config.get('nodes', []):
                    for cpe_match in node.get('cpeMatch', []):
                        cpe_name = cpe_match.get('criteria', '')
                        if cpe_name:
                            affected_products.append(cpe_name)
            
            # Extract references
            references = []
            for ref in cve_data.get('references', []):
                references.append(ref.get('url', ''))
            
            # Extract CWE IDs
            cwe_ids = []
            weaknesses = cve_data.get('weaknesses', [])
            for weakness in weaknesses:
                for desc in weakness.get('description', []):
                    if desc.get('lang') == 'en':
                        cwe_ids.append(desc.get('value', ''))
            
            return Vulnerability(
                cve_id=cve_id,
                title=f"CVE-{cve_id}",
                description=description,
                severity=severity,
                cvss_v3_score=cvss_v3_score,
                cvss_v2_score=cvss_v2_score,
                published_date=published_date,
                modified_date=modified_date,
                affected_products=affected_products,
                references=references,
                cwe_ids=cwe_ids,
                exploit_available=False,  # Will be updated by exploit feed
                patch_available=False,    # Will be updated by vendor feeds
                vendor_advisories=[],
                threat_intelligence={}
            )
            
        except Exception as e:
            self.logger.error(f"Failed to parse NVD vulnerability: {str(e)}")
            return None
    
    async def update_exploit_db_feed(self) -> int:
        """Update exploit availability from Exploit-DB"""
        try:
            updated_count = 0
            
            async with aiohttp.ClientSession() as session:
                # Get recent exploits
                params = {
                    'type': 'remote',
                    'platform': 'multiple',
                    'sort': 'date',
                    'order': 'desc'
                }
                
                async with session.get(self.feeds['exploit_db']['url'], params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        for exploit in data.get('data', []):
                            # Extract CVE from exploit description
                            cve_matches = self._extract_cve_from_text(exploit.get('description', ''))
                            
                            for cve_id in cve_matches:
                                # Update vulnerability with exploit information
                                vulnerability = await self.database.get_vulnerability_by_cve(cve_id)
                                if vulnerability:
                                    vulnerability.exploit_available = True
                                    await self.database.store_vulnerability(vulnerability)
                                    updated_count += 1
                            
                            # Rate limiting
                            await asyncio.sleep(1.0 / self.feeds['exploit_db']['rate_limit'])
            
            self.feeds['exploit_db']['last_update'] = datetime.now(timezone.utc)
            self.logger.info(f"Updated {updated_count} vulnerabilities with exploit information")
            
            return updated_count
            
        except Exception as e:
            self.logger.error(f"Failed to update Exploit-DB feed: {str(e)}")
            return 0
    
    def _extract_cve_from_text(self, text: str) -> List[str]:
        """Extract CVE IDs from text"""
        import re
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        return re.findall(cve_pattern, text, re.IGNORECASE)


class VulnerabilityDBServer:
    """MCP Server for vulnerability database operations"""
    
    def __init__(self, db_path: str = "vulnerability_db.sqlite"):
        self.server = Server("vulnerability-db")
        self.logger = logging.getLogger(__name__)
        self.database = VulnerabilityDatabase(db_path)
        self.feed_manager = VulnerabilityFeedManager(self.database)
        self.registry = ToolRegistry()
        
        self._register_tools()
        self._setup_handlers()
    
    def _register_tools(self):
        """Register vulnerability database tools"""
        
        self.registry.register_tool(ToolCapability(
            name="search_vulnerabilities",
            description="Search vulnerability database with filters",
            parameters=[
                ToolParameter("query", "string", "Search query (CVE ID, keywords)", False),
                ToolParameter("severity", "string", "Filter by severity (critical, high, medium, low)", False),
                ToolParameter("min_cvss", "number", "Minimum CVSS score", False),
                ToolParameter("max_cvss", "number", "Maximum CVSS score", False),
                ToolParameter("exploit_available", "boolean", "Filter by exploit availability", False),
                ToolParameter("published_after", "string", "Published after date (ISO format)", False),
                ToolParameter("published_before", "string", "Published before date (ISO format)", False),
                ToolParameter("limit", "integer", "Maximum results to return", False, 100)
            ],
            category="vulnerability_search",
            requires_auth=False,
            risk_level="low"
        ))
        
        self.registry.register_tool(ToolCapability(
            name="get_vulnerability_details",
            description="Get detailed information about a specific vulnerability",
            parameters=[
                ToolParameter("cve_id", "string", "CVE identifier", True)
            ],
            category="vulnerability_lookup",
            requires_auth=False,
            risk_level="low"
        ))
        
        self.registry.register_tool(ToolCapability(
            name="check_product_vulnerabilities",
            description="Check vulnerabilities affecting specific products",
            parameters=[
                ToolParameter("vendor", "string", "Product vendor", True),
                ToolParameter("product", "string", "Product name", True),
                ToolParameter("version", "string", "Product version", False),
                ToolParameter("severity_filter", "string", "Minimum severity level", False, "medium")
            ],
            category="product_assessment",
            requires_auth=False,
            risk_level="low"
        ))
        
        self.registry.register_tool(ToolCapability(
            name="update_vulnerability_feeds",
            description="Update vulnerability database from external feeds",
            parameters=[
                ToolParameter("feed_sources", "array", "Feed sources to update", False, ["nvd", "exploit_db"]),
                ToolParameter("days_back", "integer", "Days to look back for updates", False, 7),
                ToolParameter("force_update", "boolean", "Force update even if recently updated", False, False)
            ],
            category="database_maintenance",
            requires_auth=True,
            risk_level="low"
        ))
        
        self.registry.register_tool(ToolCapability(
            name="vulnerability_statistics",
            description="Get vulnerability database statistics and trends",
            parameters=[
                ToolParameter("time_period", "string", "Time period for statistics (7d, 30d, 90d)", False, "30d"),
                ToolParameter("group_by", "string", "Group statistics by (severity, date, vendor)", False, "severity")
            ],
            category="analytics",
            requires_auth=False,
            risk_level="low"
        ))
        
        self.registry.register_tool(ToolCapability(
            name="vulnerability_correlation",
            description="Correlate vulnerabilities with threat intelligence",
            parameters=[
                ToolParameter("cve_ids", "array", "List of CVE IDs to correlate", True),
                ToolParameter("include_exploits", "boolean", "Include exploit information", False, True),
                ToolParameter("include_patches", "boolean", "Include patch information", False, True)
            ],
            category="threat_correlation",
            requires_auth=False,
            risk_level="low"
        ))
    
    def _setup_handlers(self):
        """Setup MCP request handlers"""
        
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """List available vulnerability database tools"""
            tools = []
            
            for capability in self.registry.get_all_capabilities():
                tools.append(Tool(
                    name=capability.name,
                    description=capability.description,
                    inputSchema={
                        "type": "object",
                        "properties": {
                            param.name: {
                                "type": param.type,
                                "description": param.description,
                                **({"default": param.default_value} if param.default_value is not None else {})
                            }
                            for param in capability.parameters
                        },
                        "required": [param.name for param in capability.parameters if param.required]
                    }
                ))
            
            return tools
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> CallToolResult:
            """Execute vulnerability database tool"""
            try:
                start_time = datetime.now()
                
                if name == "search_vulnerabilities":
                    result = await self._search_vulnerabilities(arguments)
                elif name == "get_vulnerability_details":
                    result = await self._get_vulnerability_details(arguments)
                elif name == "check_product_vulnerabilities":
                    result = await self._check_product_vulnerabilities(arguments)
                elif name == "update_vulnerability_feeds":
                    result = await self._update_vulnerability_feeds(arguments)
                elif name == "vulnerability_statistics":
                    result = await self._vulnerability_statistics(arguments)
                elif name == "vulnerability_correlation":
                    result = await self._vulnerability_correlation(arguments)
                else:
                    return CallToolResult(
                        content=[TextContent(
                            type="text",
                            text=f"Unknown tool: {name}"
                        )],
                        isError=True
                    )
                
                execution_time = (datetime.now() - start_time).total_seconds() * 1000
                result['execution_time_ms'] = execution_time
                
                return CallToolResult(
                    content=[TextContent(
                        type="text",
                        text=json.dumps(result, indent=2, default=str)
                    )]
                )
                
            except Exception as e:
                self.logger.error(f"Tool execution failed: {str(e)}")
                return CallToolResult(
                    content=[TextContent(
                        type="text",
                        text=f"Tool execution failed: {str(e)}"
                    )],
                    isError=True
                )
    
    async def _search_vulnerabilities(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Search vulnerabilities with filters"""
        query = arguments.get('query', '')
        filters = {}
        
        # Build filters from arguments
        for key in ['severity', 'min_cvss', 'max_cvss', 'exploit_available', 
                   'published_after', 'published_before']:
            if key in arguments:
                filters[key] = arguments[key]
        
        limit = arguments.get('limit', 100)
        
        start_time = datetime.now()
        vulnerabilities = await self.database.search_vulnerabilities(query, filters, limit)
        search_time = (datetime.now() - start_time).total_seconds() * 1000
        
        result = VulnerabilitySearchResult(
            query=query,
            total_results=len(vulnerabilities),
            vulnerabilities=vulnerabilities,
            search_time_ms=search_time,
            filters_applied=filters
        )
        
        return result.to_dict()
    
    async def _get_vulnerability_details(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Get detailed vulnerability information"""
        cve_id = arguments['cve_id']
        
        vulnerability = await self.database.get_vulnerability_by_cve(cve_id)
        
        if vulnerability:
            return {
                'found': True,
                'vulnerability': vulnerability.to_dict()
            }
        else:
            return {
                'found': False,
                'message': f"Vulnerability {cve_id} not found in database"
            }
    
    async def _check_product_vulnerabilities(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Check vulnerabilities for specific product"""
        vendor = arguments['vendor']
        product = arguments['product']
        version = arguments.get('version')
        severity_filter = arguments.get('severity_filter', 'medium')
        
        # Search for product-related vulnerabilities
        query = f"{vendor} {product}"
        if version:
            query += f" {version}"
        
        filters = {'severity': severity_filter}
        vulnerabilities = await self.database.search_vulnerabilities(query, filters, 1000)
        
        # Filter by product match
        relevant_vulns = []
        for vuln in vulnerabilities:
            for affected_product in vuln.affected_products:
                if vendor.lower() in affected_product.lower() and product.lower() in affected_product.lower():
                    relevant_vulns.append(vuln)
                    break
        
        return {
            'vendor': vendor,
            'product': product,
            'version': version,
            'total_vulnerabilities': len(relevant_vulns),
            'vulnerabilities': [vuln.to_dict() for vuln in relevant_vulns[:50]],  # Limit results
            'severity_breakdown': self._calculate_severity_breakdown(relevant_vulns)
        }
    
    async def _update_vulnerability_feeds(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Update vulnerability feeds"""
        feed_sources = arguments.get('feed_sources', ['nvd', 'exploit_db'])
        days_back = arguments.get('days_back', 7)
        force_update = arguments.get('force_update', False)
        
        results = {}
        
        for feed_source in feed_sources:
            try:
                if feed_source == 'nvd':
                    updated_count = await self.feed_manager.update_nvd_feed(days_back)
                    results[feed_source] = {
                        'status': 'success',
                        'updated_count': updated_count
                    }
                elif feed_source == 'exploit_db':
                    updated_count = await self.feed_manager.update_exploit_db_feed()
                    results[feed_source] = {
                        'status': 'success',
                        'updated_count': updated_count
                    }
                else:
                    results[feed_source] = {
                        'status': 'error',
                        'message': f"Unknown feed source: {feed_source}"
                    }
            except Exception as e:
                results[feed_source] = {
                    'status': 'error',
                    'message': str(e)
                }
        
        return {
            'update_results': results,
            'total_updated': sum(r.get('updated_count', 0) for r in results.values() if r.get('status') == 'success')
        }
    
    async def _vulnerability_statistics(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        time_period = arguments.get('time_period', '30d')
        group_by = arguments.get('group_by', 'severity')
        
        # Calculate date range
        days = int(time_period.rstrip('d'))
        start_date = datetime.now(timezone.utc) - timedelta(days=days)
        
        filters = {'published_after': start_date.isoformat()}
        vulnerabilities = await self.database.search_vulnerabilities('', filters, 10000)
        
        stats = {
            'time_period': time_period,
            'total_vulnerabilities': len(vulnerabilities),
            'date_range': {
                'start': start_date.isoformat(),
                'end': datetime.now(timezone.utc).isoformat()
            }
        }
        
        if group_by == 'severity':
            stats['severity_breakdown'] = self._calculate_severity_breakdown(vulnerabilities)
        elif group_by == 'date':
            stats['daily_breakdown'] = self._calculate_daily_breakdown(vulnerabilities)
        
        return stats
    
    async def _vulnerability_correlation(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Correlate vulnerabilities with threat intelligence"""
        cve_ids = arguments['cve_ids']
        include_exploits = arguments.get('include_exploits', True)
        include_patches = arguments.get('include_patches', True)
        
        correlations = []
        
        for cve_id in cve_ids:
            vulnerability = await self.database.get_vulnerability_by_cve(cve_id)
            
            if vulnerability:
                correlation = {
                    'cve_id': cve_id,
                    'vulnerability': vulnerability.to_dict(),
                    'threat_level': self._calculate_threat_level(vulnerability),
                    'exploit_risk': vulnerability.exploit_available,
                    'patch_status': vulnerability.patch_available
                }
                
                if include_exploits and vulnerability.exploit_available:
                    correlation['exploit_details'] = {
                        'available': True,
                        'sources': ['exploit-db']  # Would be populated from actual data
                    }
                
                if include_patches:
                    correlation['patch_details'] = {
                        'available': vulnerability.patch_available,
                        'vendor_advisories': vulnerability.vendor_advisories
                    }
                
                correlations.append(correlation)
            else:
                correlations.append({
                    'cve_id': cve_id,
                    'found': False
                })
        
        return {
            'correlations': correlations,
            'summary': {
                'total_cves': len(cve_ids),
                'found_cves': len([c for c in correlations if c.get('vulnerability')]),
                'high_risk_cves': len([c for c in correlations if c.get('threat_level') == 'high']),
                'exploitable_cves': len([c for c in correlations if c.get('exploit_risk')])
            }
        }
    
    def _calculate_severity_breakdown(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Calculate severity breakdown"""
        breakdown = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'unknown': 0}
        
        for vuln in vulnerabilities:
            breakdown[vuln.severity] = breakdown.get(vuln.severity, 0) + 1
        
        return breakdown
    
    def _calculate_daily_breakdown(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Calculate daily breakdown"""
        breakdown = {}
        
        for vuln in vulnerabilities:
            date_key = vuln.published_date.strftime('%Y-%m-%d')
            breakdown[date_key] = breakdown.get(date_key, 0) + 1
        
        return breakdown
    
    def _calculate_threat_level(self, vulnerability: Vulnerability) -> str:
        """Calculate overall threat level"""
        if vulnerability.exploit_available and vulnerability.cvss_v3_score and vulnerability.cvss_v3_score >= 7.0:
            return 'critical'
        elif vulnerability.cvss_v3_score and vulnerability.cvss_v3_score >= 7.0:
            return 'high'
        elif vulnerability.exploit_available:
            return 'high'
        elif vulnerability.cvss_v3_score and vulnerability.cvss_v3_score >= 4.0:
            return 'medium'
        else:
            return 'low'
    
    async def initialize(self):
        """Initialize the vulnerability database server"""
        await self.database.initialize()
        self.logger.info("Vulnerability Database MCP Server initialized")
    
    async def run(self):
        """Run the MCP server"""
        await self.initialize()
        
        async with ClientSession(StdioServerParameters()) as session:
            await session.initialize()
            
            self.logger.info("Vulnerability Database MCP Server running...")
            
            try:
                while True:
                    await asyncio.sleep(1)
            except KeyboardInterrupt:
                self.logger.info("Shutting down Vulnerability Database MCP Server...")


# Example usage
async def main():
    """Example usage of Vulnerability Database MCP Server"""
    server = VulnerabilityDBServer()
    await server.run()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())